function InlineLineupEditor({
  matchId,
  stopId,
  teamA,
  teamB,
  teamARoster,
  teamBRoster,
  fetchTeamRoster,
  lineups,
  onSave,
  onCancel,
}: {
  matchId: string;
  stopId: string;
  teamA: { id: string; name: string };
  teamB: { id: string; name: string };
  teamARoster: PlayerLite[];
  teamBRoster: PlayerLite[];
  fetchTeamRoster: (teamId: string) => Promise<PlayerLite[]>;
  lineups: Record<string, Record<string, PlayerLite[]>>;
  onSave: (lineups: { teamA: PlayerLite[]; teamB: PlayerLite[] }) => void;
  onCancel: () => void;
}) {
  const [teamALineup, setTeamALineup] = useState<(PlayerLite | undefined)[]>([undefined, undefined, undefined, undefined]);
  const [teamBLineup, setTeamBLineup] = useState<(PlayerLite | undefined)[]>([undefined, undefined, undefined, undefined]);
  const [selectedPlayers, setSelectedPlayers] = useState<Set<string>>(new Set());
  const [isSaving, setIsSaving] = useState(false);
  const [loadedRosters, setLoadedRosters] = useState<{ teamA: PlayerLite[]; teamB: PlayerLite[] }>({ teamA: [], teamB: [] });

  // Fetch team rosters for this specific stop when component mounts
  useEffect(() => {
    const loadRosters = async () => {
      if (teamA.id && teamB.id && stopId) {
        try {
          const [responseA, responseB] = await Promise.all([
            fetch(`/api/captain/team/${teamA.id}/stops/${stopId}/roster`),
            fetch(`/api/captain/team/${teamB.id}/stops/${stopId}/roster`)
          ]);
          
          const [dataA, dataB] = await Promise.all([
            responseA.json(),
            responseB.json()
          ]);
          
          const rosterA = dataA.items || [];
          const rosterB = dataB.items || [];
          
          setLoadedRosters({ teamA: rosterA, teamB: rosterB });
        } catch (error) {
          console.error('Failed to load stop-specific rosters:', error);
          // Fallback to tournament-wide rosters
          const [rosterA, rosterB] = await Promise.all([
            fetchTeamRoster(teamA.id),
            fetchTeamRoster(teamB.id)
          ]);
          setLoadedRosters({ teamA: rosterA, teamB: rosterB });
        }
      }
    };
    loadRosters();
  }, [teamA.id, teamB.id, stopId, fetchTeamRoster]);

  // Initialize lineups when component mounts or when editing starts
  useEffect(() => {
    // Check if we have existing lineups for this match
    const existingLineups = lineups[matchId];
    if (existingLineups) {
      const teamALineupData = existingLineups[teamA.id] || [];
      const teamBLineupData = existingLineups[teamB.id] || [];
      
      // Set the lineups with existing data
      setTeamALineup([
        teamALineupData[0] || undefined,
        teamALineupData[1] || undefined,
        teamALineupData[2] || undefined,
        teamALineupData[3] || undefined
      ]);
      
      setTeamBLineup([
        teamBLineupData[0] || undefined,
        teamBLineupData[1] || undefined,
        teamBLineupData[2] || undefined,
        teamBLineupData[3] || undefined
      ]);
      
      // Set selected players
      const allSelectedPlayers = new Set([
        ...teamALineupData.map(p => p.id),
        ...teamBLineupData.map(p => p.id)
      ]);
      setSelectedPlayers(allSelectedPlayers);
    } else {
      // Reset to empty state
      setTeamALineup([undefined, undefined, undefined, undefined]);
      setTeamBLineup([undefined, undefined, undefined, undefined]);
      setSelectedPlayers(new Set());
    }
  }, [matchId, teamA.id, teamB.id]); // Removed 'lineups' from dependencies

  // Separate effect to handle lineup changes for this specific match
  useEffect(() => {
    const existingLineups = lineups[matchId];
    if (existingLineups) {
      const teamALineupData = existingLineups[teamA.id] || [];
      const teamBLineupData = existingLineups[teamB.id] || [];
      
      // Only update if the data has actually changed
      const currentTeamAIds = teamALineup.map(p => p?.id).filter(Boolean);
      const currentTeamBIds = teamBLineup.map(p => p?.id).filter(Boolean);
      const newTeamAIds = teamALineupData.map(p => p.id);
      const newTeamBIds = teamBLineupData.map(p => p.id);
      
      const teamAChanged = JSON.stringify(currentTeamAIds.sort()) !== JSON.stringify(newTeamAIds.sort());
      const teamBChanged = JSON.stringify(currentTeamBIds.sort()) !== JSON.stringify(newTeamBIds.sort());
      
      if (teamAChanged || teamBChanged) {
        setTeamALineup([
          teamALineupData[0] || undefined,
          teamALineupData[1] || undefined,
          teamALineupData[2] || undefined,
          teamALineupData[3] || undefined
        ]);
        
        setTeamBLineup([
          teamBLineupData[0] || undefined,
          teamBLineupData[1] || undefined,
          teamBLineupData[2] || undefined,
          teamBLineupData[3] || undefined
        ]);
        
        const allSelectedPlayers = new Set([
          ...teamALineupData.map(p => p.id),
          ...teamBLineupData.map(p => p.id)
        ]);
        setSelectedPlayers(allSelectedPlayers);
      }
    }
  }, [lineups[matchId]]); // Only watch this specific match's lineup data

  const addPlayerToLineup = (player: PlayerLite, teamId: string, slotIndex: number) => {
    const isTeamA = teamId === teamA.id;
    const currentLineup = isTeamA ? teamALineup : teamBLineup;
    const currentPlayer = currentLineup[slotIndex];
    
    // Check gender constraints: slots 0,1 are male, slots 2,3 are female
    const expectedGender = slotIndex < 2 ? 'MALE' : 'FEMALE';
    if (player.gender !== expectedGender) return;

    // Update selectedPlayers first to avoid race conditions
    setSelectedPlayers(prev => {
      const newSet = new Set(prev);
      
      // Remove current player from selectedPlayers if there is one
      if (currentPlayer) {
        newSet.delete(currentPlayer.id);
      }
      
      // Remove the new player from selectedPlayers if they're already selected elsewhere
      if (newSet.has(player.id)) {
        newSet.delete(player.id);
      }
      
      // Add the new player
      newSet.add(player.id);
      
      return newSet;
    });

    // Update lineup state
    if (isTeamA) {
      setTeamALineup(prev => {
        const newLineup = [...prev];
        
        // Remove the new player from other slots if they exist
        for (let i = 0; i < newLineup.length; i++) {
          if (newLineup[i]?.id === player.id) {
            newLineup[i] = undefined;
          }
        }
        
        // Add player to the new slot
        newLineup[slotIndex] = player;
        return newLineup;
      });
    } else {
      setTeamBLineup(prev => {
        const newLineup = [...prev];
        
        // Remove the new player from other slots if they exist
        for (let i = 0; i < newLineup.length; i++) {
          if (newLineup[i]?.id === player.id) {
            newLineup[i] = undefined;
          }
        }
        
        // Add player to the new slot
        newLineup[slotIndex] = player;
        return newLineup;
      });
    }
  };

  const removePlayerFromLineup = (playerId: string, teamId: string, slotIndex: number) => {
    const isTeamA = teamId === teamA.id;
    
    // Update selectedPlayers first
    setSelectedPlayers(prev => {
      const newSet = new Set(prev);
      newSet.delete(playerId);
      return newSet;
    });
    
    // Update lineup state
    if (isTeamA) {
      setTeamALineup(prev => {
        const newLineup = [...prev];
        newLineup[slotIndex] = undefined as any;
        return newLineup;
      });
    } else {
      setTeamBLineup(prev => {
        const newLineup = [...prev];
        newLineup[slotIndex] = undefined as any;
        return newLineup;
      });
    }
  };

  const getAvailablePlayers = (teamId: string, slotIndex: number) => {
    const isTeamA = teamId === teamA.id;
    const roster = isTeamA ? loadedRosters.teamA : loadedRosters.teamB;
    const expectedGender = slotIndex < 2 ? 'MALE' : 'FEMALE';
    const currentLineup = isTeamA ? teamALineup : teamBLineup;
    const currentPlayer = currentLineup[slotIndex];
    
    // Filter by gender and exclude players selected in OTHER slots
    return roster.filter(p => {
      if (p.gender !== expectedGender) return false;
      
      // If this is the currently selected player in this slot, include them
      if (currentPlayer && p.id === currentPlayer.id) return true;
      
      // Otherwise, exclude if they're selected in any other slot
      return !selectedPlayers.has(p.id);
    });
  };

  const isLineupComplete = teamALineup.filter(p => p !== undefined).length === 4 && teamBLineup.filter(p => p !== undefined).length === 4;

  const handleSave = async () => {
    if (isSaving) return; // Prevent double-clicks
    
    setIsSaving(true);
    try {
      await onSave({ 
        teamA: teamALineup.filter(p => p !== undefined) as PlayerLite[], 
        teamB: teamBLineup.filter(p => p !== undefined) as PlayerLite[] 
      });
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div className="mt-3 p-3 bg-surface-2 rounded border">
      <div className="flex items-center justify-between mb-3">
        <h3 className="text-sm font-semibold">Edit Lineups</h3>
        <div className="flex gap-2">
          <button
            className="px-2 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
            onClick={handleSave}
            disabled={!isLineupComplete || isSaving}
          >
            {isSaving ? 'Saving...' : 'Confirm Lineup'}
          </button>
          <button
            className="btn btn-ghost text-xs"
            onClick={onCancel}
          >
            Cancel
          </button>
        </div>
      </div>

      <div className="grid grid-cols-2 gap-4">
        {/* Team A */}
        <div>
          <h4 className="text-xs font-medium mb-2 text-muted">{teamA.name}</h4>
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <label className="text-xs font-medium w-4">1:</label>
              <select
                className="flex-1 p-1 text-xs border rounded"
                value={teamALineup[0]?.id || ''}
                onChange={(e) => {
                  if (e.target.value) {
                    const player = loadedRosters.teamA.find(p => p.id === e.target.value);
                    if (player) addPlayerToLineup(player, teamA.id, 0);
                  } else if (teamALineup[0]) {
                    removePlayerFromLineup(teamALineup[0].id, teamA.id, 0);
                  }
                }}
              >
                <option value="">Select Player 1</option>
                {getAvailablePlayers(teamA.id, 0).map(player => (
                  <option key={player.id} value={player.id}>
                    {player.name}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="flex items-center gap-2">
              <label className="text-xs font-medium w-4">2:</label>
              <select
                className="flex-1 p-1 text-xs border rounded"
                value={teamALineup[1]?.id || ''}
                onChange={(e) => {
                  if (e.target.value) {
                    const player = loadedRosters.teamA.find(p => p.id === e.target.value);
                    if (player) addPlayerToLineup(player, teamA.id, 1);
                  } else if (teamALineup[1]) {
                    removePlayerFromLineup(teamALineup[1].id, teamA.id, 1);
                  }
                }}
              >
                <option value="">Select Player 2</option>
                {getAvailablePlayers(teamA.id, 1).map(player => (
                  <option key={player.id} value={player.id}>
                    {player.name}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="flex items-center gap-2">
              <label className="text-xs font-medium w-4">3:</label>
              <select
                className="flex-1 p-1 text-xs border rounded"
                value={teamALineup[2]?.id || ''}
                onChange={(e) => {
                  if (e.target.value) {
                    const player = loadedRosters.teamA.find(p => p.id === e.target.value);
                    if (player) addPlayerToLineup(player, teamA.id, 2);
                  } else if (teamALineup[2]) {
                    removePlayerFromLineup(teamALineup[2].id, teamA.id, 2);
                  }
                }}
              >
                <option value="">Select Player 3</option>
                {getAvailablePlayers(teamA.id, 2).map(player => (
                  <option key={player.id} value={player.id}>
                    {player.name}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="flex items-center gap-2">
              <label className="text-xs font-medium w-4">4:</label>
              <select
                className="flex-1 p-1 text-xs border rounded"
                value={teamALineup[3]?.id || ''}
                onChange={(e) => {
                  if (e.target.value) {
                    const player = loadedRosters.teamA.find(p => p.id === e.target.value);
                    if (player) addPlayerToLineup(player, teamA.id, 3);
                  } else if (teamALineup[3]) {
                    removePlayerFromLineup(teamALineup[3].id, teamA.id, 3);
                  }
                }}
              >
                <option value="">Select Player 4</option>
                {getAvailablePlayers(teamA.id, 3).map(player => (
                  <option key={player.id} value={player.id}>
                    {player.name}
                  </option>
                ))}
              </select>
            </div>
