import { NextResponse } from 'next/server';
import { prisma } from '@/server/db';
import { makeRoundRobin } from '@/server/scheduling/roundRobin';
import { Slot } from '@prisma/client'; // uses your existing enum

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

const SLOTS: Slot[] = [
  // adjust if names differ in your schema
  'MENS', 'WOMENS', 'MIXED1', 'MIXED2', 'TIEBREAKER'
] as any;

export async function POST(_req: Request, { params }: { params: { stopId: string }}) {
  const stop = await prisma.stop.findUnique({
    where: { id: params.stopId },
    include: { tournament: true, teamLinks: { include: { team: true }} }
  });
  if (!stop) return NextResponse.json({ error: 'Stop not found' }, { status: 404 });

  const teamIds = stop.teamLinks.map(l => l.teamId);
  if (teamIds.length < 2) return NextResponse.json({ error: 'Need at least 2 teams' }, { status: 400 });

  // idempotency: if rounds already exist, exit gracefully
  const existingRounds = await prisma.round.count({ where: { stopId: stop.id }});
  if (existingRounds > 0) return NextResponse.json({ ok: true, skipped: 'Rounds already exist' });

  const rounds = makeRoundRobin(teamIds);
  // create rounds -> matches -> default games
  await prisma.$transaction(async (tx) => {
    for (let r = 0; r < rounds.length; r++) {
      const round = await tx.round.create({
        data: { stopId: stop.id, index: r + 1, name: `Round ${r + 1}` }
      });
      for (const [homeTeamId, awayTeamId] of rounds[r]) {
        const match = await tx.match.create({
          data: { roundId: round.id, homeTeamId, awayTeamId }
        });
        await Promise.all(SLOTS.map(slot =>
          tx.game.create({ data: { matchId: match.id, slot } })
        ));
      }
    }
  });

  return NextResponse.json({ ok: true, rounds: rounds.length });
}
