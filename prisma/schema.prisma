generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// *
/// * ---------- Clubs ----------
model Club {
  id                 String              @id @default(cuid())
  fullName           String
  name               String
  address1           String?
  city               String?
  region             String?
  country            String              @default("Canada")
  postalCode         String?
  phone              String?
  email              String?
  description        String?
  directorId         String?
  logo               String?
  createdAt          DateTime            @default(now())
  address            String?
  updatedAt          DateTime            @default(now()) @db.Timestamptz(6)
  Player             Player[]
  Stop               Stop[]
  Team               Team[]
  tournamentCaptains TournamentCaptain[]
  tournamentClubs    TournamentClub[]
  director           Player?             @relation("ClubDirector", fields: [directorId], references: [id], onDelete: SetNull)
}

/// *
/// * ---------- Players ----------
model Player {
  id                     String                   @id @default(cuid())
  name                   String?
  gender                 Gender
  clubId                 String
  clerkUserId            String?                  @unique
  createdAt              DateTime                 @default(now())
  firstName              String?
  lastName               String?
  email                  String?                  @unique
  phone                  String?
  city                   String?
  region                 String?
  country                String?                  @default("Canada")
  age                    Int?
  dupr                   Float?
  duprSingles            Float?
  duprDoubles            Float?
  clubRatingSingles      Float?
  clubRatingDoubles      Float?
  displayAge             Boolean                  @default(true)
  displayLocation        Boolean                  @default(true)
  birthdayYear           Int?
  birthdayMonth          Int?
  birthdayDay            Int?
  birthday               DateTime?                @db.Timestamptz(6)
  updatedAt              DateTime                 @default(now()) @db.Timestamptz(6)
  isAppAdmin             Boolean                  @default(false)
  CaptainInvite          CaptainInvite[]
  lineupEntriesAsP1      LineupEntry[]            @relation("LineupPlayer1")
  lineupEntriesAsP2      LineupEntry[]            @relation("LineupPlayer2")
  club                   Club                     @relation(fields: [clubId], references: [id], onUpdate: NoAction)
  clubsAsDirector        Club[]                   @relation("ClubDirector")
  stopsManaged           Stop[]                   @relation("StopEventManager")
  stopRosterLinks        StopTeamPlayer[]         @relation("PlayerRoster")
  teamsAsCaptain         Team[]                   @relation("TeamCaptain")
  teamLinks              TeamPlayer[]
  tournamentAdminLinks   TournamentAdmin[]
  TournamentCaptain      TournamentCaptain[]
  TournamentEventManager TournamentEventManager[]
  matchTiebreakerDecisions Match[] @relation("MatchTiebreakerDecider")

  @@index([clubId])
  @@index([birthdayYear, birthdayMonth, birthdayDay], map: "Player_birthday_idx")
  @@index([firstName])
  @@index([lastName])
  @@index([clubId, gender]) // For filtering players by club and gender
}

/// *
/// * ---------- Teams ----------
model Team {
  id              String             @id @default(cuid())
  name            String
  createdAt       DateTime           @default(now())
  tournamentId    String
  clubId          String
  captainId       String?
  division        Division           @default(INTERMEDIATE)
  updatedAt       DateTime           @default(now()) @updatedAt @db.Timestamptz(6)
  levelId         String?
  bracketId       String?
  CaptainInvite   CaptainInvite[]
  lineups         Lineup[]
  matchesA        Match[]            @relation("MatchTeamA")
  matchesB        Match[]            @relation("MatchTeamB")
  stopLinks       StopTeam[]
  stopRosterLinks StopTeamPlayer[]   @relation("TeamRoster")
  bracket         TournamentBracket? @relation(fields: [bracketId], references: [id], onUpdate: NoAction)
  captain         Player?            @relation("TeamCaptain", fields: [captainId], references: [id], onUpdate: NoAction)
  club            Club               @relation(fields: [clubId], references: [id], onDelete: SetNull, onUpdate: NoAction)
  tournament      Tournament         @relation(fields: [tournamentId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  playerLinks     TeamPlayer[]
  matchTiebreakerWins Match[] @relation("MatchTiebreakerWinner")

  @@unique([tournamentId, clubId, captainId])
  @@unique([tournamentId, clubId, bracketId])
  @@unique([tournamentId, clubId, levelId])
  @@index([tournamentId])
  @@index([clubId])
  @@index([captainId])
  @@index([bracketId])
  @@index([levelId])
  @@index([tournamentId], map: "ix_Team_tournamentId")
}

/// *
/// * ---------- Tournament + admins ----------
model Tournament {
  id                     String                   @id @default(cuid())
  name                   String
  createdAt              DateTime                 @default(now())
  type                   TournamentType           @default(TEAM_FORMAT)
  updatedAt              DateTime                 @default(now()) @updatedAt @db.Timestamptz(6)
  maxTeamSize            Int?
  CaptainInvite          CaptainInvite[]
  stops                  Stop[]
  teams                  Team[]
  TeamPlayer             TeamPlayer[]
  admins                 TournamentAdmin[]
  brackets               TournamentBracket[]
  TournamentCaptain      TournamentCaptain[]
  clubs                  TournamentClub[]
  TournamentEventManager TournamentEventManager[]
}

model TournamentAdmin {
  tournamentId String
  playerId     String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @default(now()) @db.Timestamptz(6)
  player       Player     @relation(fields: [playerId], references: [id], onDelete: Cascade)
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@id([tournamentId, playerId])
}

/// *
/// * ---------- Team roster (enforces one team per tournament) ----------
model TeamPlayer {
  teamId       String
  playerId     String
  tournamentId String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @default(now()) @db.Timestamptz(6)
  player       Player     @relation(fields: [playerId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  team         Team       @relation(fields: [teamId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([teamId, playerId])
  @@unique([teamId, playerId], map: "uq_TeamPlayer_team_player")
  @@index([tournamentId])
  @@index([playerId], map: "ix_teamplayer_player")
}

/// *
/// * ---------- Stops ----------
model Stop {
  id             String           @id @default(cuid())
  name           String
  createdAt      DateTime         @default(now())
  tournamentId   String
  clubId         String?
  startAt        DateTime         @db.Timestamptz(6)
  endAt          DateTime?        @db.Timestamptz(6)
  updatedAt      DateTime         @default(now()) @db.Timestamptz(6)
  eventManagerId String?
  lineupDeadline DateTime?        @db.Timestamptz(6) // Deadline for captain lineup submission
  Lineup         Lineup[]
  rounds         Round[]
  club           Club?            @relation(fields: [clubId], references: [id], onUpdate: NoAction)
  eventManager   Player?          @relation("StopEventManager", fields: [eventManagerId], references: [id], onUpdate: NoAction)
  tournament     Tournament       @relation(fields: [tournamentId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  teams          StopTeam[]
  StopTeamPlayer StopTeamPlayer[] @relation("StopRoster")

  @@index([tournamentId])
  @@index([clubId])
  @@index([eventManagerId])
  @@index([endAt])
  @@index([startAt])
  @@index([tournamentId], map: "ix_Stop_tournamentId")
}

model StopTeam {
  stopId    String
  teamId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @db.Timestamptz(6)
  stop      Stop     @relation(fields: [stopId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([stopId, teamId])
}

model StopTeamPlayer {
  stopId    String
  teamId    String
  playerId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @db.Timestamptz(6)
  player    Player   @relation("PlayerRoster", fields: [playerId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  stop      Stop     @relation("StopRoster", fields: [stopId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  team      Team     @relation("TeamRoster", fields: [teamId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([stopId, teamId, playerId])
  @@index([playerId], map: "ix_StopTeamPlayer_player")
  @@index([teamId], map: "ix_StopTeamPlayer_team")
  @@index([stopId, teamId]) // For querying roster by stop and team
  @@index([stopId, playerId]) // For checking player availability
}

/// *
/// * ---------- Rounds, Matches & Games (Correct hierarchy: Round → Match → Game) ----------
/// * Round: A round of play within a stop
/// * Match: A matchup between two teams (or one team vs bye)
/// * Game: Individual game slots within a match (Men's Doubles, Women's Doubles, Mixed 1, Mixed 2, Tiebreaker)
model Round {
  id        String   @id @default(cuid())
  stopId    String
  idx       Int
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @db.Timestamptz(6)
  lineups   Lineup[]
  matches   Match[]
  stop      Stop     @relation(fields: [stopId], references: [id], onDelete: Cascade)

  @@unique([stopId, idx])
  @@index([stopId], map: "ix_round_stop")
}

/// *
/// * A matchup between two teams within a round.
/// * This represents the logical "match" - two teams playing against each other.
model Match {
  id              String    @id(map: "Match_new_pkey") @default(cuid())
  roundId         String
  teamAId         String?
  teamBId         String?
  isBye           Boolean   @default(false)
  forfeitTeam     String?   // 'A' for teamA forfeit, 'B' for teamB forfeit, null for no forfeit
  createdAt       DateTime  @default(now()) @db.Timestamp(6)
  updatedAt       DateTime  @default(now()) @db.Timestamptz(6)
  games           Game[]
  round           Round     @relation(fields: [roundId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "Match_new_roundId_fkey")
  teamA           Team?     @relation("MatchTeamA", fields: [teamAId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Match_new_teamAId_fkey")
  teamB           Team?     @relation("MatchTeamB", fields: [teamBId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Match_new_teamBId_fkey")
  tiebreakerStatus        MatchTiebreakerStatus @default(NONE)
  tiebreakerWinnerTeamId  String?
  tiebreakerGameId        String? @unique
  tiebreakerDecidedAt     DateTime? @db.Timestamptz(6)
  tiebreakerDecidedById   String?
  tiebreakerDecisionNotes String?
  totalPointsTeamA        Int?
  totalPointsTeamB        Int?
  tiebreakerDecidedBy     Player?   @relation("MatchTiebreakerDecider", fields: [tiebreakerDecidedById], references: [id], onDelete: SetNull)
  tiebreakerGame          Game?     @relation("MatchTiebreakerGame", fields: [tiebreakerGameId], references: [id], onDelete: SetNull)
  tiebreakerWinnerTeam    Team?     @relation("MatchTiebreakerWinner", fields: [tiebreakerWinnerTeamId], references: [id], onDelete: SetNull)

  @@index([roundId])
  @@index([teamAId])
  @@index([teamBId])
  @@index([tiebreakerWinnerTeamId])
  @@index([roundId, isBye]) // For filtering out bye matches
  @@index([tiebreakerStatus]) // For filtering matches needing tiebreakers
}

/// *
/// * Individual game slots within a match.
/// * Each match has 5 potential games: Men's Doubles, Women's Doubles, Mixed 1, Mixed 2, Tiebreaker
model Game {
  id                    String    @id(map: "Game_new_pkey") @default(cuid())
  matchId               String
  slot                  GameSlot?
  teamAScore            Int?
  teamBScore            Int?
  teamALineup           Json?
  teamBLineup           Json?
  lineupConfirmed       Boolean?  @default(false)
  courtNumber           String?
  isComplete            Boolean?  @default(false)
  startedAt             DateTime? @db.Timestamptz(6)
  endedAt               DateTime? @db.Timestamptz(6)
  createdAt             DateTime  @default(now()) @db.Timestamp(6)
  updatedAt             DateTime  @default(now()) @db.Timestamptz(6)
  teamAScoreSubmitted   Boolean?  @default(false) // Team A captain submitted score
  teamBScoreSubmitted   Boolean?  @default(false) // Team B captain submitted score
  teamASubmittedScore   Int? // Score submitted by Team A
  teamBSubmittedScore   Int? // Score submitted by Team B
  match                 Match     @relation(fields: [matchId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "Game_new_matchId_fkey")
  tiebreakerForMatch    Match?    @relation("MatchTiebreakerGame")
  scoreSubmissions      GameScoreSubmission[]

  @@unique([matchId, slot], map: "Game_new_matchId_slot_key")
  @@index([matchId])
  @@index([isComplete, startedAt]) // For filtering incomplete games
  @@index([courtNumber]) // For filtering by court
}

/// *
/// * ---------- Lineups (use GameSlot) ----------
model Lineup {
  id        String        @id @default(cuid())
  roundId   String
  teamId    String
  createdAt DateTime      @default(now())
  stopId    String?
  updatedAt DateTime      @default(now()) @updatedAt @db.Timestamptz(6)
  round     Round         @relation(fields: [roundId], references: [id], onDelete: Cascade)
  Stop      Stop?         @relation(fields: [stopId], references: [id], onDelete: Cascade)
  team      Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  entries   LineupEntry[]

  @@unique([roundId, teamId])
  @@index([teamId])
}

model LineupEntry {
  id        String   @id @default(cuid())
  lineupId  String
  player1Id String
  player2Id String
  slot      GameSlot
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  lineup    Lineup   @relation(fields: [lineupId], references: [id], onDelete: Cascade)
  player1   Player   @relation("LineupPlayer1", fields: [player1Id], references: [id])
  player2   Player   @relation("LineupPlayer2", fields: [player2Id], references: [id])

  @@unique([lineupId, slot])
  @@index([player1Id, slot]) // For checking player participation
  @@index([player2Id, slot]) // For checking player participation
}

/// *
/// * ---------- Captain invites ----------
model CaptainInvite {
  id           String     @id @default(cuid())
  tournamentId String
  teamId       String
  captainId    String
  email        String
  token        String     @unique
  createdAt    DateTime   @default(now()) @db.Timestamptz(6)
  usedAt       DateTime?  @db.Timestamptz(6)
  expiresAt    DateTime   @db.Timestamptz(6)
  updatedAt    DateTime   @default(now()) @db.Timestamptz(6)
  captain      Player     @relation(fields: [captainId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  team         Team       @relation(fields: [teamId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([tournamentId, teamId], map: "captaininvite_tournament_team_idx")
}

/// *
/// * ---------- Tournament config tables ----------
model TournamentClub {
  tournamentId       String
  clubId             String
  createdAt          DateTime   @default(now()) @db.Timestamptz(6)
  captainAccessToken String?    @unique // 5-char token for captain portal access
  club               Club       @relation(fields: [clubId], references: [id], onDelete: Cascade)
  tournament         Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@id([tournamentId, clubId])
  @@index([clubId])
}

model TournamentBracket {
  id           String     @id @default(cuid())
  tournamentId String
  name         String
  idx          Int        @default(0)
  teams        Team[]
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, name])
  @@index([tournamentId, idx], map: "TournamentBracket_tournamentId_idx")
}

/// *
/// * ---------- Per-tournament Captain (governance) ----------
/// * A player can captain at most one participating club *within the same tournament*,
/// * but may captain clubs in other tournaments.
model TournamentCaptain {
  tournamentId String
  clubId       String
  playerId     String
  createdAt    DateTime   @default(now()) @db.Timestamptz(6)
  club         Club       @relation(fields: [clubId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  player       Player     @relation(fields: [playerId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([tournamentId, clubId])
  @@unique([tournamentId, playerId])
  @@index([playerId])
}

model TournamentEventManager {
  tournamentId String
  playerId     String
  createdAt    DateTime   @default(now()) @db.Timestamptz(6)
  Player       Player     @relation(fields: [playerId], references: [id], onDelete: Cascade)
  Tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@id([tournamentId, playerId])
  @@index([playerId])
}

model GameScoreSubmission {
  id           String   @id @default(cuid())
  gameId       String
  teamId       String
  teamName     String?
  reportedScore String  // JSON string like "11-3" or "2-11"
  submittedAt  DateTime @default(now()) @db.Timestamptz(6)
  game         Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId])
  @@index([teamId])
}

/// *
/// * Enums (keep mapping to existing PG types to avoid enum migration churn)
enum Gender {
  MALE
  FEMALE

  @@map("gender")
}

/// *
/// * Game slot types for individual games within a match
enum GameSlot {
  MENS_DOUBLES
  WOMENS_DOUBLES
  MIXED_1
  MIXED_2
  TIEBREAKER
}

enum MatchTiebreakerStatus {
  NONE
  NEEDS_DECISION
  REQUIRES_TIEBREAKER
  PENDING_TIEBREAKER
  DECIDED_POINTS
  DECIDED_TIEBREAKER
}

enum Division {
  INTERMEDIATE
  ADVANCED
}

enum TournamentType {
  TEAM_FORMAT
  SINGLE_ELIMINATION
  DOUBLE_ELIMINATION
  ROUND_ROBIN
  POOL_PLAY
  LADDER_TOURNAMENT
}

/// *
/// * ---------- Club Registration ----------
model ClubRegistration {
  id           String   @id @default(cuid())
  name         String
  address1     String
  city         String
  region       String
  postalCode   String
  phone        String?
  contactEmail String
  contactName  String
  contactPhone String?
  description  String?
  status       String   @default("PENDING") // PENDING, APPROVED, REJECTED
  submittedAt  DateTime @default(now())
  reviewedAt   DateTime?
  reviewedBy   String?
  notes        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @db.Timestamptz(6)
}
