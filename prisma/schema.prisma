generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// *
/// * ---------- Clubs ----------
model Club {
  id                 String              @id @default(cuid())
  fullName           String
  name               String
  address1           String?
  city               String?
  region             String?
  country            String              @default("Canada")
  postalCode         String?
  phone              String?
  email              String?
  description        String?
  directorId         String?
  logo               String?
  createdAt          DateTime            @default(now())
  address            String?
  updatedAt          DateTime            @default(now()) @db.Timestamptz(6)
  
  // New Status & Subscription Fields
  status              ClubStatus      @default(ACTIVE)
  subscriptionId      String?         // Stripe subscription ID
  subscriptionStatus  SubscriptionStatus?
  
  Player              Player[]
  Stop                Stop[]
  Team                Team[]
  tournamentCaptains  TournamentCaptain[]
  tournamentClubs     TournamentClub[]
  stopBracketCapacity StopBracketCapacity[]
  
  // Relations
  director            Player?             @relation("ClubDirector", fields: [directorId], references: [id], onDelete: SetNull)
  directors           ClubDirector[]      // New multi-director support
  tournamentsOwned    Tournament[]        @relation("ClubTournaments")
}


/// *
/// * ---------- Players ----------
model Player {
  id                     String                   @id @default(cuid())
  name                   String?
  image                  String?
  gender                 Gender
  clubId                 String
  clerkUserId            String?                  @unique
  createdAt              DateTime                 @default(now())
  firstName              String?
  lastName               String?
  email                  String?                  @unique
  phone                  String?
  city                   String?
  region                 String?
  country                String?                  @default("Canada")
  age                    Int?
  duprSingles            Float?
  duprDoubles            Float?
  clubRatingSingles      Float?
  clubRatingDoubles      Float?
  displayAge             Boolean                  @default(true)
  displayLocation        Boolean                  @default(true)
  birthdayYear           Int?
  birthdayMonth          Int?
  birthdayDay            Int?
  birthday               DateTime?                @db.Timestamptz(6)
  updatedAt              DateTime                 @default(now()) @db.Timestamptz(6)
  isAppAdmin             Boolean                  @default(false)
  disabled               Boolean                  @default(false)
  disabledAt             DateTime?
  disabledBy             String?                  // Player ID of admin who disabled
  CaptainInvite          CaptainInvite[]
  lineupEntriesAsP1      LineupEntry[]            @relation("LineupPlayer1")
  lineupEntriesAsP2      LineupEntry[]            @relation("LineupPlayer2")
  club                   Club                     @relation(fields: [clubId], references: [id], onUpdate: NoAction)
  clubsAsDirector        Club[]                   @relation("ClubDirector")
  clubDirectorRoles      ClubDirector[]           // New multi-director support
  stopsManaged           Stop[]                   @relation("StopEventManager")

  stopRosterLinks        StopTeamPlayer[]         @relation("PlayerRoster")
  teamsAsCaptain         Team[]                   @relation("TeamCaptain")
  teamLinks              TeamPlayer[]
  tournamentAdminLinks   TournamentAdmin[]
  TournamentCaptain      TournamentCaptain[]
  TournamentEventManager TournamentEventManager[]
  matchTiebreakerDecisions Match[] @relation("MatchTiebreakerDecider")
  tournamentRegistrations TournamentRegistration[]
  tournamentInvitesReceived TournamentInvite[]  @relation("TournamentInvitesReceived")
  tournamentInvitesSent  TournamentInvite[]     @relation("TournamentInvitesSent")
  inviteRequestsSent     InviteRequest[]        @relation("InviteRequestsSent")
  inviteRequestsReviewed InviteRequest[]        @relation("ReviewedRequests")
  tournamentWaitlist     TournamentWaitlist[]
  actAsAdminActions      ActAsAuditLog[]        @relation("ActAsAdmin")
  actAsTargetActions     ActAsAuditLog[]        @relation("ActAsTarget")
  mergesAsKept           PlayerMergeLog[]       @relation("MergedIntoPlayer")
  mergesPerformed        PlayerMergeLog[]       @relation("MergePerformedBy")

  @@index([clubId])
  @@index([birthdayYear, birthdayMonth, birthdayDay], map: "Player_birthday_idx")
  @@index([firstName])
  @@index([lastName])
  @@index([clubId, gender]) // For filtering players by club and gender
}

/// *
/// * ---------- Teams ----------
model Team {
  id              String             @id @default(cuid())
  name            String
  createdAt       DateTime           @default(now())
  tournamentId    String
  clubId          String
  captainId       String?
  division        Division?          @default(INTERMEDIATE)
  updatedAt       DateTime           @default(now()) @updatedAt @db.Timestamptz(6)
  levelId         String?
  bracketId       String?
  CaptainInvite   CaptainInvite[]
  lineups         Lineup[]
  matchesA        Match[]            @relation("MatchTeamA")
  matchesB        Match[]            @relation("MatchTeamB")
  stopLinks       StopTeam[]
  stopRosterLinks StopTeamPlayer[]   @relation("TeamRoster")
  bracket         TournamentBracket? @relation(fields: [bracketId], references: [id], onUpdate: NoAction)
  captain         Player?            @relation("TeamCaptain", fields: [captainId], references: [id], onUpdate: NoAction)
  club            Club               @relation(fields: [clubId], references: [id], onDelete: SetNull, onUpdate: NoAction)
  tournament      Tournament         @relation(fields: [tournamentId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  playerLinks     TeamPlayer[]
  matchTiebreakerWins Match[] @relation("MatchTiebreakerWinner")
  matchWins       Match[]            @relation("MatchWinner")

  @@unique([tournamentId, clubId, captainId])
  @@unique([tournamentId, clubId, bracketId])
  @@unique([tournamentId, clubId, levelId])
  @@index([tournamentId])
  @@index([clubId])
  @@index([captainId])
  @@index([bracketId])
  @@index([levelId])
  @@index([tournamentId], map: "ix_Team_tournamentId")
}

/// *
/// * ---------- Tournament + admins ----------
model Tournament {
  id                     String                   @id @default(cuid())
  name                   String
  description            String?
  createdAt              DateTime                 @default(now())
  type                   TournamentType           @default(TEAM_FORMAT)
  updatedAt              DateTime                 @default(now()) @updatedAt @db.Timestamptz(6)
  startDate              DateTime?
  endDate                DateTime?
  location               String?
  maxTeamSize            Int?
  gamesPerMatch          Int?

  ownerClubId            String?
  ownerClub              Club?                    @relation("ClubTournaments", fields: [ownerClubId], references: [id])

  // Registration Settings
  registrationStatus     RegistrationStatus       @default(CLOSED)
  registrationType       RegistrationType         @default(FREE)
  registrationCost       Int?                     // in cents, null if free
  registrationOpens      DateTime?
  registrationDeadline   DateTime?
  maxPlayers             Int?                     // null = unlimited
  restrictionNotes       String[]                 // Array of restriction messages
  isWaitlistEnabled      Boolean                  @default(true)
  pricingModel           PricingModel             @default(TOURNAMENT_WIDE)

  CaptainInvite          CaptainInvite[]
  stops                  Stop[]
  teams                  Team[]
  TeamPlayer             TeamPlayer[]
  admins                 TournamentAdmin[]
  brackets               TournamentBracket[]
  TournamentCaptain      TournamentCaptain[]
  clubs                  TournamentClub[]
  TournamentEventManager TournamentEventManager[]
  registrations          TournamentRegistration[]
  invites                TournamentInvite[]
  inviteRequests         InviteRequest[]
  waitlist               TournamentWaitlist[]
  stopPricing            StopPricing[]
  bracketPricing         BracketPricing[]
  bracketGameTypeConfig  BracketGameTypeConfig[]
  stopBracketCapacity    StopBracketCapacity[]
}

model TournamentAdmin {
  tournamentId String
  playerId     String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @default(now()) @db.Timestamptz(6)
  player       Player     @relation(fields: [playerId], references: [id], onDelete: Cascade)
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@id([tournamentId, playerId])
}

/// *
/// * ---------- Team roster (enforces one team per tournament) ----------
model TeamPlayer {
  teamId       String
  playerId     String
  tournamentId String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @default(now()) @db.Timestamptz(6)
  player       Player     @relation(fields: [playerId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  team         Team       @relation(fields: [teamId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([teamId, playerId])
  @@unique([teamId, playerId], map: "uq_TeamPlayer_team_player")
  @@index([tournamentId])
  @@index([playerId], map: "ix_teamplayer_player")
}

/// *
/// * ---------- Stops ----------
model Stop {
  id             String           @id @default(cuid())
  name           String
  createdAt      DateTime         @default(now())
  tournamentId   String
  clubId         String?
  startAt        DateTime         @db.Timestamptz(6)
  endAt          DateTime?        @db.Timestamptz(6)
  updatedAt      DateTime         @default(now()) @db.Timestamptz(6)
  eventManagerId String?
  lineupDeadline DateTime?        @db.Timestamptz(6) // Deadline for captain lineup submission
  Lineup         Lineup[]
  rounds         Round[]
  club           Club?            @relation(fields: [clubId], references: [id], onUpdate: NoAction)
  eventManager   Player?          @relation("StopEventManager", fields: [eventManagerId], references: [id], onUpdate: NoAction)
  tournament          Tournament            @relation(fields: [tournamentId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  teams               StopTeam[]
  StopTeamPlayer      StopTeamPlayer[]      @relation("StopRoster")
  stopPricing         StopPricing[]
  stopBracketCapacity StopBracketCapacity[]

  @@index([tournamentId])
  @@index([clubId])
  @@index([eventManagerId])
  @@index([endAt])
  @@index([startAt])
  @@index([tournamentId], map: "ix_Stop_tournamentId")
}

model StopTeam {
  stopId    String
  teamId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @db.Timestamptz(6)
  stop      Stop     @relation(fields: [stopId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([stopId, teamId])
}

model StopTeamPlayer {
  stopId        String
  teamId        String
  playerId      String
  paymentMethod PaymentMethod @default(UNPAID)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @default(now()) @db.Timestamptz(6)
  player        Player        @relation("PlayerRoster", fields: [playerId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  stop          Stop          @relation("StopRoster", fields: [stopId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  team          Team          @relation("TeamRoster", fields: [teamId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([stopId, teamId, playerId])
  @@index([playerId], map: "ix_StopTeamPlayer_player")
  @@index([teamId], map: "ix_StopTeamPlayer_team")
  @@index([stopId, teamId]) // For querying roster by stop and team
  @@index([stopId, playerId]) // For checking player availability
}

/// *
/// * ---------- Rounds, Matches & Games (Correct hierarchy: Round → Match → Game) ----------
/// * Round: A round of play within a stop
/// * Match: A matchup between two teams (or one team vs bye)
/// * Game: Individual game slots within a match (Men's Doubles, Women's Doubles, Mixed 1, Mixed 2, Tiebreaker)
model Round {
  id          String   @id @default(cuid())
  stopId      String
  idx         Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @db.Timestamptz(6)
  bracketType String?  // For bracket tournaments: 'WINNER' | 'LOSER' | 'FINALS' (null for team format)
  depth       Int?     // For bracket tournaments: bracket depth (0=finals, 1=semis, 2=quarters, etc.)
  lineups     Lineup[]
  matches     Match[]
  stop        Stop     @relation(fields: [stopId], references: [id], onDelete: Cascade)

  @@unique([stopId, idx])
  @@index([stopId], map: "ix_round_stop")
  @@index([stopId, bracketType]) // For filtering by bracket type
}

/// *
/// * A matchup between two teams within a round.
/// * This represents the logical "match" - two teams playing against each other.
model Match {
  id              String    @id(map: "Match_new_pkey") @default(cuid())
  roundId         String
  teamAId         String?
  teamBId         String?
  isBye           Boolean   @default(false)
  forfeitTeam     String?   // 'A' for teamA forfeit, 'B' for teamB forfeit, null for no forfeit
  createdAt       DateTime  @default(now()) @db.Timestamp(6)
  updatedAt       DateTime  @default(now()) @db.Timestamptz(6)
  seedA           Int?
  seedB           Int?
  sourceMatchAId  String?
  sourceMatchBId  String?
  bracketPosition Int?
  winnerId        String?
  games           Game[]
  round           Round     @relation(fields: [roundId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "Match_new_roundId_fkey")
  teamA           Team?     @relation("MatchTeamA", fields: [teamAId], references: [id], onDelete: SetNull, onUpdate: NoAction, map: "Match_new_teamAId_fkey")
  teamB           Team?     @relation("MatchTeamB", fields: [teamBId], references: [id], onDelete: SetNull, onUpdate: NoAction, map: "Match_new_teamBId_fkey")
  sourceMatchA    Match?    @relation("MatchProgressionA", fields: [sourceMatchAId], references: [id], onDelete: SetNull)
  sourceMatchB    Match?    @relation("MatchProgressionB", fields: [sourceMatchBId], references: [id], onDelete: SetNull)
  childMatchesFromA Match[] @relation("MatchProgressionA")
  childMatchesFromB Match[] @relation("MatchProgressionB")
  tiebreakerStatus        MatchTiebreakerStatus @default(NONE)
  tiebreakerWinnerTeamId  String?
  tiebreakerGameId        String?   @unique
  tiebreakerDecidedAt     DateTime? @db.Timestamptz(6)
  tiebreakerDecidedById   String?
  tiebreakerDecisionNotes String?
  totalPointsTeamA        Int?
  totalPointsTeamB        Int?
  tiebreakerDecidedBy     Player?   @relation("MatchTiebreakerDecider", fields: [tiebreakerDecidedById], references: [id], onDelete: SetNull)
  tiebreakerGame          Game?     @relation("MatchTiebreakerGame", fields: [tiebreakerGameId], references: [id], onDelete: SetNull)
  tiebreakerWinnerTeam    Team?     @relation("MatchTiebreakerWinner", fields: [tiebreakerWinnerTeamId], references: [id], onDelete: SetNull)
  winner                  Team?     @relation("MatchWinner", fields: [winnerId], references: [id], onDelete: SetNull)

  @@index([roundId])
  @@index([teamAId])
  @@index([teamBId])
  @@index([tiebreakerWinnerTeamId])
  @@index([winnerId])
  @@index([roundId, isBye]) // For filtering out bye matches
  @@index([tiebreakerStatus]) // For filtering matches needing tiebreakers
  @@index([sourceMatchAId])
  @@index([sourceMatchBId])
}

/// *
/// * Individual game slots within a match.
/// * Each match has 5 potential games: Men's Doubles, Women's Doubles, Mixed 1, Mixed 2, Tiebreaker
model Game {
  id                    String    @id(map: "Game_new_pkey") @default(cuid())
  matchId               String
  slot                  GameSlot?
  bracketId             String?   // For DOUBLE_ELIMINATION_CLUBS: which bracket this game belongs to
  teamAScore            Int?
  teamBScore            Int?
  courtNumber           String?
  isComplete            Boolean?  @default(false)
  startedAt             DateTime? @db.Timestamptz(6)
  endedAt               DateTime? @db.Timestamptz(6)
  createdAt             DateTime  @default(now()) @db.Timestamp(6)
  updatedAt             DateTime  @default(now()) @db.Timestamptz(6)
  teamAScoreSubmitted   Boolean?  @default(false) // Team A captain submitted score
  teamBScoreSubmitted   Boolean?  @default(false) // Team B captain submitted score
  teamASubmittedScore   Int? // Score submitted by Team A
  teamBSubmittedScore   Int? // Score submitted by Team B
  match                 Match     @relation(fields: [matchId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "Game_new_matchId_fkey")
  bracket               TournamentBracket? @relation(fields: [bracketId], references: [id], onDelete: SetNull)
  tiebreakerForMatch    Match?    @relation("MatchTiebreakerGame")
  scoreSubmissions      GameScoreSubmission[]

  @@unique([matchId, slot, bracketId], map: "Game_matchId_slot_bracketId_key")
  @@index([matchId])
  @@index([bracketId]) // For querying games by bracket
  @@index([isComplete, startedAt]) // For filtering incomplete games
  @@index([courtNumber]) // For filtering by court
}

/// *
/// * ---------- Lineups (use GameSlot) ----------
model Lineup {
  id        String             @id @default(cuid())
  roundId   String
  teamId    String
  bracketId String?            // For DE Clubs tournaments - allows multiple lineups per team per round
  createdAt DateTime           @default(now())
  stopId    String?
  updatedAt DateTime           @default(now()) @updatedAt @db.Timestamptz(6)
  round     Round              @relation(fields: [roundId], references: [id], onDelete: Cascade)
  Stop      Stop?              @relation(fields: [stopId], references: [id], onDelete: Cascade)
  team      Team               @relation(fields: [teamId], references: [id], onDelete: Cascade)
  bracket   TournamentBracket? @relation(fields: [bracketId], references: [id], onDelete: SetNull)
  entries   LineupEntry[]

  @@unique([roundId, teamId, bracketId])
  @@index([teamId])
  @@index([bracketId])
}

model LineupEntry {
  id        String   @id @default(cuid())
  lineupId  String
  player1Id String
  player2Id String
  slot      GameSlot
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  lineup    Lineup   @relation(fields: [lineupId], references: [id], onDelete: Cascade)
  player1   Player   @relation("LineupPlayer1", fields: [player1Id], references: [id])
  player2   Player   @relation("LineupPlayer2", fields: [player2Id], references: [id])

  @@unique([lineupId, slot])
  @@index([player1Id, slot]) // For checking player participation
  @@index([player2Id, slot]) // For checking player participation
}

/// *
/// * ---------- Captain invites ----------
model CaptainInvite {
  id           String     @id @default(cuid())
  tournamentId String
  teamId       String
  captainId    String
  playerId     String?
  email        String
  token        String     @unique
  createdAt    DateTime   @default(now()) @db.Timestamptz(6)
  usedAt       DateTime?  @db.Timestamptz(6)
  expiresAt    DateTime   @db.Timestamptz(6)
  updatedAt    DateTime   @default(now()) @db.Timestamptz(6)
  captain      Player     @relation(fields: [captainId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  team         Team       @relation(fields: [teamId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([tournamentId, teamId], map: "captaininvite_tournament_team_idx")
}

/// *
/// * ---------- Tournament config tables ----------
model TournamentClub {
  tournamentId       String
  clubId             String
  createdAt          DateTime   @default(now()) @db.Timestamptz(6)
  captainAccessToken String?    @unique // 5-char token for captain portal access
  club               Club       @relation(fields: [clubId], references: [id], onDelete: Cascade)
  tournament         Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@id([tournamentId, clubId])
  @@index([clubId])
}

model TournamentBracket {
  id           String     @id @default(cuid())
  tournamentId String
  name         String
  idx          Int        @default(0)
  teams                 Team[]
  games                 Game[]                  // Games that belong to this bracket (for DOUBLE_ELIMINATION_CLUBS)
  lineups               Lineup[]                // Lineups for this bracket (for DOUBLE_ELIMINATION_CLUBS)
  tournament            Tournament              @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  bracketPricing        BracketPricing[]
  bracketGameTypeConfig BracketGameTypeConfig[]
  stopBracketCapacity   StopBracketCapacity[]

  @@unique([tournamentId, name])
  @@index([tournamentId, idx], map: "TournamentBracket_tournamentId_idx")
}

/// *
/// * ---------- Per-tournament Captain (governance) ----------
/// * A player can captain at most one participating club *within the same tournament*,
/// * but may captain clubs in other tournaments.
model TournamentCaptain {
  tournamentId String
  clubId       String
  playerId     String
  createdAt    DateTime   @default(now()) @db.Timestamptz(6)
  club         Club       @relation(fields: [clubId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  player       Player     @relation(fields: [playerId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([tournamentId, clubId])
  @@unique([tournamentId, playerId])
  @@index([playerId])
}

model TournamentEventManager {
  tournamentId String
  playerId     String
  createdAt    DateTime   @default(now()) @db.Timestamptz(6)
  Player       Player     @relation(fields: [playerId], references: [id], onDelete: Cascade)
  Tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@id([tournamentId, playerId])
  @@index([playerId])
}

model GameScoreSubmission {
  id           String   @id @default(cuid())
  gameId       String
  teamId       String
  teamName     String?
  reportedScore String  // JSON string like "11-3" or "2-11"
  submittedAt  DateTime @default(now()) @db.Timestamptz(6)
  game         Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId])
  @@index([teamId])
}

/// *
/// * Enums (keep mapping to existing PG types to avoid enum migration churn)
enum Gender {
  MALE
  FEMALE

  @@map("gender")
}

/// *
/// * Game slot types for individual games within a match
enum GameSlot {
  MENS_DOUBLES
  WOMENS_DOUBLES
  MIXED_1
  MIXED_2
  TIEBREAKER
}

enum MatchTiebreakerStatus {
  NONE
  NEEDS_DECISION
  REQUIRES_TIEBREAKER
  PENDING_TIEBREAKER
  DECIDED_POINTS
  DECIDED_TIEBREAKER
}

enum Division {
  INTERMEDIATE
  ADVANCED
}

enum TournamentType {
  TEAM_FORMAT
  SINGLE_ELIMINATION
  DOUBLE_ELIMINATION
  DOUBLE_ELIMINATION_CLUBS
  ROUND_ROBIN
  POOL_PLAY
  LADDER_TOURNAMENT
}

/// *
/// * Enums (keep mapping to existing PG types to avoid enum migration churn)
enum RegistrationStatus {
  OPEN
  INVITE_ONLY
  CLOSED
}

enum RegistrationType {
  FREE
  PAID
}

/// *
/// * ---------- Tournament Registration System ----------

model TournamentRegistration {
  id                String                    @id @default(cuid())
  tournamentId      String
  playerId          String

  status            RegistrationPlayerStatus  @default(REGISTERED)
  registeredAt      DateTime                  @default(now())
  withdrawnAt       DateTime?
  rejectedAt        DateTime?
  rejectedBy        String?                   // Player ID of admin who rejected
  rejectionReason   String?                   // Required if rejected
  notes             String?

  // Payment
  paymentStatus     PaymentStatus             @default(PENDING)
  paymentId         String?                   // Stripe payment ID
  refundId          String?                   // Stripe refund ID
  amountPaid        Int?                      // in cents

  tournament        Tournament                @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  player            Player                    @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, playerId])
  @@index([tournamentId, status])
  @@index([playerId])
}

model TournamentInvite {
  id                String        @id @default(cuid())
  tournamentId      String
  playerId          String?       // null if inviting by email (not yet a player)

  // For email invites (player doesn't exist yet)
  inviteEmail       String?
  inviteName        String?
  inviteToken       String?       @unique // For signup link

  status            InviteStatus  @default(PENDING)
  invitedBy         String        // Player ID of admin who sent invite
  createdAt         DateTime      @default(now())
  expiresAt         DateTime      // Admin-selected expiry
  respondedAt       DateTime?     // When invite was accepted/declined
  notes             String?

  acceptedAt        DateTime?
  declinedAt        DateTime?
  cancelledAt       DateTime?

  tournament        Tournament    @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  player            Player?       @relation("TournamentInvitesReceived", fields: [playerId], references: [id], onDelete: Cascade)
  invitedByPlayer   Player        @relation("TournamentInvitesSent", fields: [invitedBy], references: [id])

  @@unique([tournamentId, playerId])
  @@index([tournamentId, status])
  @@index([playerId])
  @@index([inviteEmail])
  @@index([inviteToken])
}

model InviteRequest {
  id                String              @id @default(cuid())
  tournamentId      String
  playerId          String

  status            InviteRequestStatus @default(PENDING)
  requestedAt       DateTime            @default(now())
  reviewedAt        DateTime?
  reviewedBy        String?             // Player ID of admin who reviewed
  notes             String?

  tournament        Tournament          @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  player            Player              @relation("InviteRequestsSent", fields: [playerId], references: [id], onDelete: Cascade)
  reviewer          Player?             @relation("ReviewedRequests", fields: [reviewedBy], references: [id])

  @@unique([tournamentId, playerId])
  @@index([tournamentId, status])
}

model TournamentWaitlist {
  id                    String          @id @default(cuid())
  tournamentId          String
  playerId              String

  position              Int             // Auto-calculated based on joinedAt
  joinedAt              DateTime        @default(now())

  status                WaitlistStatus  @default(ACTIVE)
  notifiedAt            DateTime?       // When spot-available email was sent
  notificationExpiresAt DateTime?       // 24h after notifiedAt

  movedToRegisteredAt   DateTime?
  removedAt             DateTime?
  promotedAt            DateTime?

  tournament            Tournament      @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  player                Player          @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, playerId])
  @@index([tournamentId, status, position])
}

/// *
/// * ---------- Advanced Configuration Models ----------
model StopPricing {
  id           String   @id @default(cuid())
  tournamentId String
  stopId       String
  cost         Int      // Cost in cents
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  stop         Stop       @relation(fields: [stopId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, stopId])
  @@index([tournamentId])
  @@index([stopId])
}

model BracketPricing {
  id           String   @id @default(cuid())
  tournamentId String
  bracketId    String
  cost         Int      // Cost in cents
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  tournament   Tournament        @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  bracket      TournamentBracket @relation(fields: [bracketId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, bracketId])
  @@index([tournamentId])
  @@index([bracketId])
}

model BracketGameTypeConfig {
  id           String   @id @default(cuid())
  tournamentId String
  bracketId    String
  gameType     String   // MENS_DOUBLES, WOMENS_DOUBLES, MIXED_DOUBLES, etc.
  isEnabled    Boolean  @default(true)
  capacity     Int?     // Optional capacity limit for this game type
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  tournament   Tournament        @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  bracket      TournamentBracket @relation(fields: [bracketId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, bracketId, gameType])
  @@index([tournamentId])
  @@index([bracketId])
  @@index([gameType])
}

model StopBracketCapacity {
  id           String   @id @default(cuid())
  tournamentId String
  stopId       String
  bracketId    String
  clubId       String?  // Only for team tournaments
  maxCapacity  Int
  currentCount Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  tournament   Tournament        @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  stop         Stop              @relation(fields: [stopId], references: [id], onDelete: Cascade)
  bracket      TournamentBracket @relation(fields: [bracketId], references: [id], onDelete: Cascade)
  club         Club?             @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, stopId, bracketId, clubId])
  @@index([tournamentId])
  @@index([stopId])
  @@index([bracketId])
  @@index([clubId])
}

enum RegistrationPlayerStatus {
  REGISTERED
  WITHDRAWN
  REJECTED
}

enum PaymentStatus {
  PENDING
  PAID
  REFUNDED
  FAILED
  COMPLETED
}

enum PaymentMethod {
  STRIPE       // Paid via Stripe (automatic)
  MANUAL       // Paid externally (cash, e-transfer, etc.)
  UNPAID       // Not paid yet
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
  EXPIRED
}

enum InviteRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum WaitlistStatus {
  ACTIVE
  NOTIFIED
  EXPIRED
  REGISTERED
  REMOVED
}

enum PricingModel {
  TOURNAMENT_WIDE
  PER_STOP
  PER_BRACKET
  PER_STOP_PER_BRACKET
}

/// *
/// * ---------- Club Registration (Legacy) ----------
model LegacyClubRegistration {
  id           String   @id @default(cuid())
  name         String
  address1     String
  city         String
  region       String
  postalCode   String
  phone        String?
  contactEmail String
  contactName  String
  contactPhone String?
  description  String?
  status       String   @default("PENDING") // PENDING, APPROVED, REJECTED
  submittedAt  DateTime @default(now())
  reviewedAt   DateTime?
  reviewedBy   String?
  notes        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @db.Timestamptz(6)

  @@map("ClubRegistration")
}

/// *
/// * ---------- New Club Director & System Models ----------

model ClubDirector {
  clubId    String
  playerId  String
  role      ClubRole @default(ADMIN)
  joinedAt  DateTime @default(now())

  club      Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  
  @@id([clubId, playerId])
  @@index([playerId])
  @@index([clubId])
}

model SystemSettings {
  id                       String   @id @default("settings")
  monthlySubscriptionPrice Int      @default(6999) // cents
  annualSubscriptionPrice  Int      @default(79999) // cents
  isSubscriptionEnabled    Boolean  @default(true)
  updatedAt                DateTime @default(now()) @updatedAt
}

enum ClubStatus {
  ACTIVE      // Free / Participating
  SUBSCRIBED  // Paid / Tournament Creator
  PAST_DUE    // Payment failed, grace period
  INACTIVE    // Cancelled / Expired
}

enum ClubRole {
  ADMIN
  MEMBER
}

enum SubscriptionStatus {
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  INCOMPLETE
  INCOMPLETE_EXPIRED
  PAUSED
}


/// *
/// * ---------- Security Audit Logs ----------
model ActAsAuditLog {
  id              String   @id @default(cuid())
  adminPlayerId   String
  targetPlayerId  String
  action          String   // 'START' | 'END' | 'ACTION'
  endpoint        String?
  ipAddress       String
  userAgent       String
  createdAt       DateTime @default(now()) @db.Timestamptz(6)
  expiresAt       DateTime @db.Timestamptz(6)

  admin    Player @relation("ActAsAdmin", fields: [adminPlayerId], references: [id])
  target   Player @relation("ActAsTarget", fields: [targetPlayerId], references: [id])

  @@index([adminPlayerId])
  @@index([targetPlayerId])
  @@index([createdAt])
}

model CaptainPortalAttempt {
  id          String   @id @default(cuid())
  token       String
  ipAddress   String
  userAgent   String
  success     Boolean
  createdAt   DateTime @default(now()) @db.Timestamptz(6)

  @@index([token, createdAt])
  @@index([ipAddress, createdAt])
}

/// *
/// * ---------- Player Merge Audit Log ----------
model PlayerMergeLog {
  id                    String   @id @default(cuid())
  primaryPlayerId       String
  secondaryPlayerId     String   // Stored for reference (player is deleted)
  secondaryPlayerName   String
  secondaryPlayerEmail  String?
  secondaryClerkUserId  String?
  mergedBy              String
  transferredData       Json?    // Summary: { rosters: 5, lineups: 12, ... }
  clerkMergeStatus      String?  // 'SUCCESS' | 'PARTIAL' | 'MANUAL_REQUIRED' | 'SKIPPED'
  clerkMergeNotes       String?
  createdAt             DateTime @default(now())

  primaryPlayer         Player   @relation("MergedIntoPlayer", fields: [primaryPlayerId], references: [id])
  admin                 Player   @relation("MergePerformedBy", fields: [mergedBy], references: [id])

  @@index([primaryPlayerId])
  @@index([mergedBy])
  @@index([createdAt])
}
